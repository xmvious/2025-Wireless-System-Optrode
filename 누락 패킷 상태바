# -*- coding: utf-8 -*-
"""
PyQt5 + PyQtGraph 기반 4채널 실시간 플로터
- USB-UART 통해 보드 데이터 수신
  기본: "v1,v2,v3,v4\n"
  권장: "seq,v1,v2,v3,v4\n"  (seq: 0~65535, 래핑)
  선택: 끝에 "*XX" 체크섬이 붙어도 파싱 시 * 앞까지만 사용
- Start: 'on\n' 전송 + CSV 로깅 시작 (CSV 헤더: SEQ,CH1..CH4)
- Stop : 'off\n' 전송 + CSV 로깅 종료
- Stim : "pulses,period,duty\n" 전송
- CH1~CH4 가시성 토글, Merge/Split 지원, 콘솔 실시간 출력
- 패킷 누락(lost) 및 간격 기반 갭(gap) 감지/표시
"""

import sys
import os
import csv
import threading
from collections import deque
from datetime import datetime

import serial
from serial import SerialException

import pyqtgraph as pg
from PyQt5 import QtWidgets, QtCore

# ===== 설정 =====
PORT = "COM3"              # 시리얼 포트
BAUDRATE = 115200
MAX_POINTS = 500           # 화면에 보일 포인트 개수
UPDATE_INTERVAL_MS = 100   # 플롯 업데이트 주기
Y_MIN, Y_MAX = 0, 3000     # Y축 범위
CHANNEL_COLORS = ['r', 'g', 'b', 'y']  # CH1~CH4 색상

# 콘솔 출력 스위치 (터미널에 실시간 출력)
PRINT_TO_CONSOLE = True


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Live ADC Data (4CH) - PyQt5 + PyQtGraph")

        # 상태 변수
        self.data_queues = [deque([0]*MAX_POINTS, maxlen=MAX_POINTS) for _ in range(4)]
        self.channel_visible = [True, True, True, True]
        self.logging_enabled = False
        self.streaming_enabled = False
        self.csv_file = None
        self.csv_writer = None
        self.last_csv_filename = None
        self.ser = None
        self.reader_thread = None
        self.reader_stop = threading.Event()
        self.merged = False  # Merge 상태

        # ---- 통계/감시용 변수 ----
        self.total_packets = 0
        self.lost_packets = 0
        self.malformed_lines = 0
        self.gap_count = 0
        self.last_seq = None            # 시퀀스 번호 추적 (0~65535)
        self.last_time = None           # 마지막 수신 시각 (Qt QTime)
        self.dt_history = deque(maxlen=200)  # 최근 간격(ms) 히스토리

        # ========== UI 구성 ==========
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        vbox = QtWidgets.QVBoxLayout(central)

        # ---- 상단 컨트롤 영역 ----
        ctrl = QtWidgets.QHBoxLayout()

        # Stim 파라미터
        ctrl.addWidget(QtWidgets.QLabel("Pulse"))
        self.pulse_edit = QtWidgets.QLineEdit()
        self.pulse_edit.setFixedWidth(70)
        ctrl.addWidget(self.pulse_edit)

        ctrl.addWidget(QtWidgets.QLabel("Period"))
        self.period_edit = QtWidgets.QLineEdit()
        self.period_edit.setFixedWidth(70)
        ctrl.addWidget(self.period_edit)

        ctrl.addWidget(QtWidgets.QLabel("Duty"))
        self.duty_edit = QtWidgets.QLineEdit()
        self.duty_edit.setFixedWidth(70)
        ctrl.addWidget(self.duty_edit)

        self.btn_stim = QtWidgets.QPushButton("Stim")
        self.btn_stim.clicked.connect(self.send_stimulus)
        ctrl.addWidget(self.btn_stim)

        ctrl.addStretch()

        # Start / Stop 버튼
        self.btn_start = QtWidgets.QPushButton("Start")
        self.btn_start.clicked.connect(self.start_logging)
        ctrl.addWidget(self.btn_start)

        self.btn_stop = QtWidgets.QPushButton("Stop")
        self.btn_stop.clicked.connect(self.stop_logging)
        ctrl.addWidget(self.btn_stop)

        # Merge / Split 버튼
        self.btn_merge_split = QtWidgets.QPushButton("Merge")
        self.btn_merge_split.clicked.connect(self.toggle_merge_split)
        ctrl.addWidget(self.btn_merge_split)

        # 채널 체크박스
        self.cb_ch = []
        for i in range(4):
            cb = QtWidgets.QCheckBox(f"CH{i+1}")
            cb.setChecked(True)
            cb.stateChanged.connect(lambda state, idx=i: self.toggle_channel(idx, state))
            self.cb_ch.append(cb)
            ctrl.addWidget(cb)

        # Open CSV 버튼
        self.btn_open = QtWidgets.QPushButton("Open CSV")
        self.btn_open.clicked.connect(self.open_csv)
        ctrl.addWidget(self.btn_open)

        vbox.addLayout(ctrl)

        # ---- 그래프 영역 ----
        self.graphics = pg.GraphicsLayoutWidget()
        vbox.addWidget(self.graphics)

        # 기본 Split 상태에서 그래프 생성
        self.create_split_plots()

        # ---- 상태바 ----
        self.status = self.statusBar()
        self.status.showMessage("Ready")

        # ---- 타이머 (그래프 업데이트) ----
        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self.update_plot)
        self.timer.start(UPDATE_INTERVAL_MS)

        # 상태바 주기적 갱신 타이머 (1초)
        self.stats_timer = QtCore.QTimer(self)
        self.stats_timer.timeout.connect(self.update_statusbar_stats)
        self.stats_timer.start(1000)

        # ---- 시리얼 연결 시도 ----
        self.try_open_serial()

        # ---- 리더 스레드 시작 ----
        self.start_reader_thread()

        # 종료 시 정리
        self.destroyed.connect(self.cleanup)
        self.resize(1000, 800)

    # ===== 시리얼 =====
    def try_open_serial(self):
        try:
            self.ser = serial.Serial(PORT, BAUDRATE, timeout=1)
            self.status.showMessage(f"Serial opened: {PORT} @ {BAUDRATE}")
        except SerialException as e:
            self.ser = None
            self.status.showMessage(f"Serial open failed: {e}")

    def start_reader_thread(self):
        self.reader_stop.clear()
        self.reader_thread = threading.Thread(target=self.reader_loop, daemon=True)
        self.reader_thread.start()

    def reader_loop(self):
        """시리얼에서 데이터 읽어오기 + 누락/갭 감지"""
        while not self.reader_stop.is_set():
            if self.ser is None:
                QtCore.QThread.msleep(200)
                continue
            try:
                raw = self.ser.readline()
                now = QtCore.QTime.currentTime()

                # 디코드
                try:
                    line = raw.decode(errors="ignore").strip()
                except Exception:
                    self.malformed_lines += 1
                    continue

                if not line:
                    continue

                # 선택적 체크섬 제거: "...,v4*XX" 형태면 '*' 앞까지만 사용
                if '*' in line:
                    line = line.split('*', 1)[0].strip()

                if "," not in line:
                    continue

                parts = [p.strip() for p in line.split(",")]

                seq = None
                values = None

                if len(parts) == 5:
                    # 형식: seq,v1,v2,v3,v4
                    try:
                        seq = int(parts[0])
                        values = [int(x) for x in parts[1:]]
                    except ValueError:
                        self.malformed_lines += 1
                        continue
                elif len(parts) == 4:
                    # 형식: v1,v2,v3,v4 (시퀀스 없음)
                    try:
                        values = [int(x) for x in parts]
                    except ValueError:
                        self.malformed_lines += 1
                        continue
                else:
                    self.malformed_lines += 1
                    continue

                # === 콘솔(터미널) 출력 ===
                if PRINT_TO_CONSOLE:
                    if seq is not None:
                        print(f"{seq},{values[0]},{values[1]},{values[2]},{values[3]}", flush=True)
                    else:
                        print(f"{values[0]},{values[1]},{values[2]},{values[3]}", flush=True)

                # === 타이밍 기반 갭 감지 ===
                if self.last_time is not None:
                    dt_ms = self.last_time.msecsTo(now)
                    if dt_ms >= 0:
                        self.dt_history.append(dt_ms)
                        if len(self.dt_history) >= 20:
                            sorted_dt = sorted(self.dt_history)
                            median_dt = sorted_dt[len(sorted_dt)//2]
                            threshold = max(10, 3 * median_dt)  # 최소 10ms
                            if dt_ms > threshold:
                                self.gap_count += 1
                                if PRINT_TO_CONSOLE:
                                    print(f"[GAP] dt={dt_ms}ms (>~{threshold}ms)", flush=True)
                self.last_time = now

                # === 시퀀스 기반 누락 계산 ===
                if seq is not None:
                    if self.last_seq is not None:
                        expected = (self.last_seq + 1) & 0xFFFF
                        missed = (seq - expected) & 0xFFFF
                        if missed != 0:
                            self.lost_packets += missed
                            if PRINT_TO_CONSOLE:
                                print(f"[LOSS] missed {missed} pkt(s): last={self.last_seq}, got={seq}", flush=True)
                    self.last_seq = seq

                self.total_packets += 1

                # === 그래프/로깅 ===
                if self.streaming_enabled:
                    for i in range(4):
                        self.data_queues[i].append(values[i])

                    if self.logging_enabled and self.csv_writer:
                        # CSV는 SEQ 포함하여 5열로 기록
                        if seq is not None:
                            self.csv_writer.writerow([seq] + values)
                        else:
                            # 시퀀스 없으면 빈 칸 채움 (형식 유지)
                            self.csv_writer.writerow([""] + values)

            except Exception:
                # 시리얼 잡음/부분 데이터 등은 조용히 무시
                pass

    # ===== 상태바 통계 갱신 =====
    def update_statusbar_stats(self):
        self.status.showMessage(
            f"pkt={self.total_packets}  loss={self.lost_packets}  malformed={self.malformed_lines}  gaps={self.gap_count}"
        )

    # ===== 버튼 핸들러 =====
    def start_logging(self):
        if self.ser is None:
            self.try_open_serial()
            if self.ser is None:
                QtWidgets.QMessageBox.warning(self, "Serial", "Serial open failed.")
                return

        if not self.logging_enabled:
            filename = f"adc_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            self.last_csv_filename = filename
            try:
                self.csv_file = open(filename, mode="w", newline="")
                self.csv_writer = csv.writer(self.csv_file)
                # 헤더: SEQ 포함
                self.csv_writer.writerow(["SEQ", "CH1", "CH2", "CH3", "CH4"])
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "CSV", f"Failed to open CSV: {e}")
                return

            try:
                self.ser.write(b"on\n")
            except Exception:
                pass

            self.logging_enabled = True
            self.streaming_enabled = True
            self.status.showMessage(f"🟢 Logging started → {filename}")

    def stop_logging(self):
        if self.logging_enabled:
            try:
                if self.ser:
                    self.ser.write(b"off\n")
            except Exception:
                pass

            self.logging_enabled = False
            self.streaming_enabled = False
            try:
                if self.csv_file:
                    self.csv_file.close()
            finally:
                self.csv_file = None
                self.csv_writer = None
            self.status.showMessage("🛑 Logging stopped. CSV file closed.")

    def send_stimulus(self):
        pulses = self.pulse_edit.text().strip()
        period = self.period_edit.text().strip()
        duty = self.duty_edit.text().strip()

        if not (pulses.isdigit() and period.isdigit() and duty.isdigit()):
            QtWidgets.QMessageBox.warning(self, "Stim", "Invalid input. Use integers.")
            return

        cmd = f"{pulses},{period},{duty}\n".encode()
        try:
            if self.ser is None:
                self.try_open_serial()
            if self.ser:
                self.ser.write(cmd)
                self.status.showMessage(f"📤 Sent stimulus: {pulses},{period},{duty}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Serial", f"Write failed: {e}")

    def toggle_channel(self, idx, state):
        self.channel_visible[idx] = (state == QtCore.Qt.Checked)

    def open_csv(self):
        if self.last_csv_filename and os.path.exists(self.last_csv_filename):
            try:
                os.startfile(self.last_csv_filename)  # Windows
            except AttributeError:
                import subprocess
                opener = "open" if sys.platform == "darwin" else "xdg-open"
                subprocess.call([opener, self.last_csv_filename])
        else:
            QtWidgets.QMessageBox.information(self, "CSV", "No CSV file to open.")

    # ===== 그래프 생성 =====
    def create_split_plots(self):
        """4채널 개별 plot 생성 (색상 유지, 스크롤/줌 가능)"""
        self.graphics.clear()
        self.plots = []
        self.curves = []
        for i in range(4):
            p = self.graphics.addPlot(row=i, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", f"CH{i+1}")
            if i == 3:
                p.setLabel("bottom", "Samples")
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            curve = p.plot([], [], pen=CHANNEL_COLORS[i])
            self.plots.append(p)
            self.curves.append(curve)

    def toggle_merge_split(self):
        """그래프 합치기 / 분리"""
        self.graphics.clear()
        if not self.merged:
            # Merge: 모든 채널 하나 그래프
            p = self.graphics.addPlot(row=0, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", "ADC Value")
            p.setLabel("bottom", "Samples")
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            self.curves = []
            for i in range(4):
                curve = p.plot([], [], pen=CHANNEL_COLORS[i], name=f"CH{i+1}")
                self.curves.append(curve)
            self.merged = True
            self.btn_merge_split.setText("Split")
        else:
            # Split: 각 채널별 plot 재생성
            self.create_split_plots()
            self.merged = False
            self.btn_merge_split.setText("Merge")

    # ===== 플롯 업데이트 =====
    def update_plot(self):
        for i in range(len(self.curves)):
            if self.channel_visible[i]:
                y = list(self.data_queues[i])
                x = list(range(len(y)))
                self.curves[i].setData(x, y, connect="finite")
            else:
                self.curves[i].setData([], [])

    # ===== 종료 =====
    def cleanup(self):
        self.reader_stop.set()
        if self.reader_thread and self.reader_thread.is_alive():
            self.reader_thread.join(timeout=1.0)
        if self.csv_file:
            try:
                self.csv_file.close()
            except Exception:
                pass
        if self.ser:
            try:
                self.ser.close()
            except Exception:
                pass


def main():
    app = QtWidgets.QApplication(sys.argv)
    pg.setConfigOptions(antialias=True, useOpenGL=False)
    win = MainWindow()
    win.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
