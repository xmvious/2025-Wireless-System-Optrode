# -*- coding: utf-8 -*-
"""
PyQt5 + PyQtGraph 기반 4채널 실시간 플로터 (바이너리 수신판)
- 수신 프레임(10B, little-endian): <Hhhhh> = seq(uint16), ch1..ch4(int16)
- Start: 'on\n' 전송 + CSV 로깅 시작 (CSV 헤더: SEQ,CH1..CH4)
- Stop : 'off\n' 전송 + CSV 로깅 종료
- Stim : "pulses,period,duty\n" 전송 (ASCII 그대로)
- 포트 선택, Merge/Split, Reset View, 단위(mV, ms) 표기
- 패킷 누락/갭 감지, 상태바에 rx pkt/s, 총 sps, per-ch sps, 16k 달성률
"""

import sys
import os
import csv
import struct
import threading
from threading import Lock
from collections import deque
from datetime import datetime

import serial
from serial import SerialException
from serial.tools import list_ports

import pyqtgraph as pg
from PyQt5 import QtWidgets, QtCore

# ===== 설정 =====
DEFAULT_PORT = "COM3"      # 초기 표시용
BAUDRATE = 115200          # 16ksps 노리면 1_000_000 이상 권장 (HW/드라이버 여건에 맞춰 조정)
MAX_POINTS = 500           # 화면에 보일 포인트 개수
UPDATE_INTERVAL_MS = 100   # 플롯 업데이트 주기
Y_MIN, Y_MAX = 0, 3000     # Y축 범위 (mV 가정)
CHANNEL_COLORS = ['r', 'g', 'b', 'y']  # CH1~CH4 색상

# 바이너리 프레임 형식
FRAME_SIZE = 10                             # <Hhhhh>
UNPACK = struct.Struct('<Hhhhh').unpack_from
SAMPLES_PER_PACKET = 4                      # 패킷당 샘플 수(4채널×1)
TARGET_TOTAL_SPS = 16000                    # 목표 총 sps (총 16 ksps)

PRINT_TO_CONSOLE = False                    # 터미널 출력 스위치


class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Live ADC Data (4CH) [Binary Rx] - PyQt5 + PyQtGraph")

        # 상태 변수
        self.data_queues = [deque([0]*MAX_POINTS, maxlen=MAX_POINTS) for _ in range(4)]
        self.channel_visible = [True, True, True, True]
        self.logging_enabled = False
        self.streaming_enabled = False
        self.csv_file = None
        self.csv_writer = None
        self.last_csv_filename = None
        self.ser = None
        self.reader_thread = None
        self.reader_stop = threading.Event()
        self.merged = False  # Merge 상태

        # 통계/감시
        self.total_packets = 0
        self.lost_packets = 0
        self.malformed_lines = 0  # (바이너리에서는 사용 거의 안함)
        self.gap_count = 0
        self.last_seq = None
        self.last_time = None
        self.dt_history = deque(maxlen=200)

        # rx rate
        self.pkts_since_last = 0
        self.rate_lock = Lock()
        self.prev_stats_time = QtCore.QTime.currentTime()

        # 버퍼(바이너리 정렬)
        self.rx_buf = bytearray()

        # ========== UI ==========
        central = QtWidgets.QWidget()
        self.setCentralWidget(central)
        vbox = QtWidgets.QVBoxLayout(central)

        # 상단 컨트롤
        ctrl = QtWidgets.QHBoxLayout()

        # Port 선택
        ctrl.addWidget(QtWidgets.QLabel("Port"))
        self.port_combo = QtWidgets.QComboBox()
        self.refresh_ports()
        ctrl.addWidget(self.port_combo)

        # Stim 파라미터 (ASCII 송신 유지)
        ctrl.addWidget(QtWidgets.QLabel("Pulse"))
        self.pulse_edit = QtWidgets.QLineEdit(); self.pulse_edit.setFixedWidth(70); ctrl.addWidget(self.pulse_edit)
        ctrl.addWidget(QtWidgets.QLabel("Period"))
        self.period_edit = QtWidgets.QLineEdit(); self.period_edit.setFixedWidth(70); ctrl.addWidget(self.period_edit)
        ctrl.addWidget(QtWidgets.QLabel("Duty"))
        self.duty_edit = QtWidgets.QLineEdit(); self.duty_edit.setFixedWidth(70); ctrl.addWidget(self.duty_edit)
        self.btn_stim = QtWidgets.QPushButton("Stim"); self.btn_stim.clicked.connect(self.send_stimulus); ctrl.addWidget(self.btn_stim)

        ctrl.addStretch()

        # Start/Stop
        self.btn_start = QtWidgets.QPushButton("Start"); self.btn_start.clicked.connect(self.start_logging); ctrl.addWidget(self.btn_start)
        self.btn_stop  = QtWidgets.QPushButton("Stop");  self.btn_stop.clicked.connect(self.stop_logging);  ctrl.addWidget(self.btn_stop)

        # Merge/Split + Reset
        self.btn_merge_split = QtWidgets.QPushButton("Merge"); self.btn_merge_split.clicked.connect(self.toggle_merge_split); ctrl.addWidget(self.btn_merge_split)
        self.btn_reset = QtWidgets.QPushButton("Reset View"); self.btn_reset.clicked.connect(self.reset_view); ctrl.addWidget(self.btn_reset)

        # 채널 토글
        self.cb_ch = []
        for i in range(4):
            cb = QtWidgets.QCheckBox(f"CH{i+1}")
            cb.setChecked(True)
            cb.stateChanged.connect(lambda state, idx=i: self.toggle_channel(idx, state))
            self.cb_ch.append(cb); ctrl.addWidget(cb)

        # Open CSV
        self.btn_open = QtWidgets.QPushButton("Open CSV"); self.btn_open.clicked.connect(self.open_csv); ctrl.addWidget(self.btn_open)

        vbox.addLayout(ctrl)

        # 그래프
        self.graphics = pg.GraphicsLayoutWidget(); vbox.addWidget(self.graphics)
        self.create_split_plots()

        # 상태바
        self.status = self.statusBar(); self.status.showMessage("Ready")

        # 타이머들
        self.timer = QtCore.QTimer(self); self.timer.timeout.connect(self.update_plot); self.timer.start(UPDATE_INTERVAL_MS)
        self.stats_timer = QtCore.QTimer(self); self.stats_timer.timeout.connect(self.update_statusbar_stats); self.stats_timer.start(1000)

        # 시리얼 & 리더 스레드
        self.try_open_serial()
        self.start_reader_thread()

        # 종료
        self.destroyed.connect(self.cleanup)
        self.resize(1000, 800)

    # ----- 포트 -----
    def refresh_ports(self):
        self.port_combo.clear()
        ports = [p.device for p in list_ports.comports()]
        if ports:
            if DEFAULT_PORT in ports:
                ports.remove(DEFAULT_PORT); ports.insert(0, DEFAULT_PORT)
            self.port_combo.addItems(ports)
        else:
            self.port_combo.addItem("No Ports")

    def try_open_serial(self):
        port_name = self.port_combo.currentText() if self.port_combo.count() > 0 else None
        if not port_name or port_name == "No Ports":
            self.status.showMessage("No serial ports available"); return
        if self.ser:
            try: self.ser.close()
            except Exception: pass
            self.ser = None
        try:
            self.ser = serial.Serial(port_name, BAUDRATE, timeout=0.02)  # 짧은 타임아웃로 루프 회전
            self.status.showMessage(f"Serial opened: {port_name} @ {BAUDRATE}")
        except SerialException as e:
            self.ser = None
            self.status.showMessage(f"Serial open failed: {e}")

    def start_reader_thread(self):
        self.reader_stop.clear()
        self.reader_thread = threading.Thread(target=self.reader_loop, daemon=True)
        self.reader_thread.start()

    # ----- 수신 루프 (바이너리 파싱) -----
    def reader_loop(self):
        while not self.reader_stop.is_set():
            if self.ser is None:
                QtCore.QThread.msleep(200); continue
            try:
                chunk = self.ser.read(4096)
                now = QtCore.QTime.currentTime()
                if not chunk:
                    # 타임아웃 → gap 감지용 시간만 갱신
                    if self.last_time is not None:
                        dt_ms = self.last_time.msecsTo(now)
                        if dt_ms >= 0:
                            self.dt_history.append(dt_ms)
                            if len(self.dt_history) >= 20:
                                median_dt = sorted(self.dt_history)[len(self.dt_history)//2]
                                threshold = max(10, 3 * median_dt)
                                if dt_ms > threshold:
                                    self.gap_count += 1
                                    if PRINT_TO_CONSOLE:
                                        print(f"[GAP] idle dt={dt_ms}ms (>~{threshold}ms)", flush=True)
                    self.last_time = now
                    continue

                self.rx_buf.extend(chunk)

                # 10바이트씩 프레임 파싱
                while len(self.rx_buf) >= FRAME_SIZE:
                    frame = self.rx_buf[:FRAME_SIZE]
                    del self.rx_buf[:FRAME_SIZE]

                    try:
                        seq, ch1, ch2, ch3, ch4 = UNPACK(frame)
                    except struct.error:
                        # 이 경우는 거의 없음(고정 길이). 혹시 정렬 깨지면 버리기.
                        self.malformed_lines += 1
                        continue

                    # 콘솔 출력(옵션)
                    if PRINT_TO_CONSOLE:
                        print(f"{seq},{ch1},{ch2},{ch3},{ch4}", flush=True)

                    # 갭 감지(패킷 간 시간)
                    if self.last_time is not None:
                        dt_ms = self.last_time.msecsTo(now)
                        if dt_ms >= 0:
                            self.dt_history.append(dt_ms)
                            if len(self.dt_history) >= 20:
                                median_dt = sorted(self.dt_history)[len(self.dt_history)//2]
                                threshold = max(10, 3 * median_dt)
                                if dt_ms > threshold:
                                    self.gap_count += 1
                                    if PRINT_TO_CONSOLE:
                                        print(f"[GAP] dt={dt_ms}ms (>~{threshold}ms)", flush=True)
                    self.last_time = now

                    # 누락 감지(16-bit wrap)
                    if self.last_seq is not None:
                        expected = (self.last_seq + 1) & 0xFFFF
                        missed = (seq - expected) & 0xFFFF
                        if missed != 0:
                            self.lost_packets += missed
                            if PRINT_TO_CONSOLE:
                                print(f"[LOSS] missed {missed} pkt(s): last={self.last_seq}, got={seq}", flush=True)
                    self.last_seq = seq

                    self.total_packets += 1
                    with self.rate_lock:
                        self.pkts_since_last += 1

                    # 그래프/로깅
                    if self.streaming_enabled:
                        vals = (ch1, ch2, ch3, ch4)
                        for i in range(4):
                            self.data_queues[i].append(vals[i])
                        if self.logging_enabled and self.csv_writer:
                            self.csv_writer.writerow([seq, ch1, ch2, ch3, ch4])

            except Exception:
                # 노이즈 등은 무시
                pass

    # ----- 상태바 -----
    def update_statusbar_stats(self):
        now = QtCore.QTime.currentTime()
        dt_s = max(0.001, self.prev_stats_time.msecsTo(now) / 1000.0)
        with self.rate_lock:
            delta_pkts = self.pkts_since_last
            self.pkts_since_last = 0
        rx_pkt_s = delta_pkts / dt_s

        total_sps = rx_pkt_s * SAMPLES_PER_PACKET
        per_ch_sps = total_sps / 4.0
        achieve = (total_sps / TARGET_TOTAL_SPS * 100.0) if TARGET_TOTAL_SPS > 0 else 0.0

        self.status.showMessage(
            f"pkt={self.total_packets}  loss={self.lost_packets}  malformed={self.malformed_lines}  gaps={self.gap_count}  |  "
            f"rx≈{rx_pkt_s:,.1f}/s  sps≈{total_sps:,.1f}  per-ch≈{per_ch_sps:,.1f}  |  target(16k)≈{achieve:,.1f}%"
        )
        self.prev_stats_time = now

    # ----- 버튼 핸들러 -----
    def start_logging(self):
        if self.ser is None:
            self.try_open_serial()
            if self.ser is None:
                QtWidgets.QMessageBox.warning(self, "Serial", "Serial open failed.")
                return

        if not self.logging_enabled:
            filename = f"adc_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            self.last_csv_filename = filename
            try:
                self.csv_file = open(filename, mode="w", newline="")
                self.csv_writer = csv.writer(self.csv_file)
                self.csv_writer.writerow(["SEQ", "CH1", "CH2", "CH3", "CH4"])
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "CSV", f"Failed to open CSV: {e}")
                return

            try:
                self.ser.write(b"on\n")  # ASCII 명령 유지
            except Exception:
                pass

            self.logging_enabled = True
            self.streaming_enabled = True
            self.status.showMessage(f"🟢 Logging started → {filename}")

    def stop_logging(self):
        if self.logging_enabled:
            try:
                if self.ser:
                    self.ser.write(b"off\n")
            except Exception:
                pass

        self.logging_enabled = False
        self.streaming_enabled = False
        try:
            if self.csv_file: self.csv_file.close()
        finally:
            self.csv_file = None; self.csv_writer = None
        self.status.showMessage("🛑 Logging stopped. CSV file closed.")

    def send_stimulus(self):
        pulses = self.pulse_edit.text().strip()
        period = self.period_edit.text().strip()
        duty = self.duty_edit.text().strip()
        if not (pulses.isdigit() and period.isdigit() and duty.isdigit()):
            QtWidgets.QMessageBox.warning(self, "Stim", "Invalid input. Use integers."); return
        cmd = f"{pulses},{period},{duty}\n".encode()
        try:
            if self.ser is None: self.try_open_serial()
            if self.ser:
                self.ser.write(cmd)
                self.status.showMessage(f"📤 Sent stimulus: {pulses},{period},{duty}")
        except Exception as e:
            QtWidgets.QMessageBox.warning(self, "Serial", f"Write failed: {e}")

    def toggle_channel(self, idx, state):
        self.channel_visible[idx] = (state == QtCore.Qt.Checked)

    def open_csv(self):
        if self.last_csv_filename and os.path.exists(self.last_csv_filename):
            try: os.startfile(self.last_csv_filename)
            except AttributeError:
                import subprocess; opener = "open" if sys.platform == "darwin" else "xdg-open"
                subprocess.call([opener, self.last_csv_filename])
        else:
            QtWidgets.QMessageBox.information(self, "CSV", "No CSV file to open.")

    # ----- 그래프 -----
    def create_split_plots(self):
        self.graphics.clear()
        self.plots, self.curves = [], []
        for i in range(4):
            p = self.graphics.addPlot(row=i, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", f"CH{i+1}", units="mV")
            if i == 3: p.setLabel("bottom", "Time", units="ms")
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            curve = p.plot([], [], pen=CHANNEL_COLORS[i])
            self.plots.append(p); self.curves.append(curve)

    def toggle_merge_split(self):
        self.graphics.clear()
        if not self.merged:
            p = self.graphics.addPlot(row=0, col=0)
            p.showGrid(x=True, y=True)
            p.setLabel("left", "Voltage", units="mV")
            p.setLabel("bottom", "Time", units="ms")
            p.setYRange(Y_MIN, Y_MAX)
            p.setMouseEnabled(x=True, y=True)
            self.curves = []
            for i in range(4):
                self.curves.append(p.plot([], [], pen=CHANNEL_COLORS[i], name=f"CH{i+1}"))
            self.merged = True; self.btn_merge_split.setText("Split")
        else:
            self.create_split_plots()
            self.merged = False; self.btn_merge_split.setText("Merge")

    def reset_view(self):
        if self.merged:
            if self.curves:
                vb = self.curves[0].getViewBox()
                vb.setXRange(0, MAX_POINTS); vb.setYRange(Y_MIN, Y_MAX)
        else:
            for c in self.curves:
                vb = c.getViewBox()
                vb.setXRange(0, MAX_POINTS); vb.setYRange(Y_MIN, Y_MAX)
        self.status.showMessage("🔄 View reset")

    def update_plot(self):
        for i in range(len(self.curves)):
            if self.channel_visible[i]:
                y = list(self.data_queues[i]); x = list(range(len(y)))
                self.curves[i].setData(x, y, connect="finite")
            else:
                self.curves[i].setData([], [])

    # ----- 종료 -----
    def cleanup(self):
        self.reader_stop.set()
        if self.reader_thread and self.reader_thread.is_alive():
            self.reader_thread.join(timeout=1.0)
        if self.csv_file:
            try: self.csv_file.close()
            except Exception: pass
        if self.ser:
            try: self.ser.close()
            except Exception: pass


def main():
    app = QtWidgets.QApplication(sys.argv)
    pg.setConfigOptions(antialias=True, useOpenGL=False)
    win = MainWindow(); win.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
