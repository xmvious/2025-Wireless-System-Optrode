/*
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 * Peripheral UART (NUS server) - Binary passthrough
 */

#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/sys/printk.h>
#include <zephyr/logging/log.h>
LOG_MODULE_REGISTER(peripheral_uart_bin, LOG_LEVEL_INF);

#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/hci.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/uuid.h>
#include <zephyr/bluetooth/gatt.h>

#include <bluetooth/services/nus.h>          /* NUS 서버 */
#include <zephyr/drivers/uart.h>
#include <zephyr/settings/settings.h>

/* ====== 설정 ====== */
#define UART_BUF_SIZE        256            /* UART 버퍼(수신/송신) */
#define UART_RX_TIMEOUT_US   50000          /* RX 타임아웃(μs) */
#define UART_WAIT_FOR_BUF_DELAY K_MSEC(50)

/* [필수] 보드의 chosen 노드 alias: nordic,nus-uart */
static const struct device *uart = DEVICE_DT_GET(DT_CHOSEN(nordic_nus_uart));

/* FIFO, 세마포 */
struct uart_data_t {
    void    *fifo_reserved;
    uint8_t  data[UART_BUF_SIZE];
    uint16_t len;
};
static K_FIFO_DEFINE(fifo_uart_tx_data);   /* BLE->UART이 실패했을 때 재전송 큐 */
static K_FIFO_DEFINE(fifo_uart_rx_data);   /* UART 수신 라인(기본 예제 유산) */

static struct bt_conn *current_conn;
static const struct device *nus_dev;       /* NUS 서버 디바이스 핸들 */

static struct k_work_delayable uart_work;

/* ===== 광고 파라미터 & 데이터 ===== */
static const struct bt_data ad[] = {
    BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
    BT_DATA_BYTES(BT_DATA_UUID128_ALL, BT_UUID_NUS_VAL),
};

/* ===== [BIN] NUS 서버 콜백: BLE→UART 바이너리 패스스루 ===== */
static void nus_received_cb(const struct bt_uuid *uuid, const uint8_t *data, size_t len)
{
    ARG_UNUSED(uuid);

    /* data,len 그대로 UART로 쪼개 전송 */
    size_t pos = 0;
    while (pos < len) {
        size_t chunk = MIN(len - pos, (size_t)UART_BUF_SIZE);
        const uint8_t *p = &data[pos];
        int err = uart_tx(uart, p, chunk, SYS_FOREVER_MS);
        if (err) {
            /* 실패 시 큐에 적재 → UART_TX_DONE에서 재시도 */
            struct uart_data_t *tx = k_malloc(sizeof(*tx));
            if (tx) {
                tx->len = chunk;
                memcpy(tx->data, p, chunk);
                k_fifo_put(&fifo_uart_tx_data, tx);
            }
        }
        pos += chunk;
    }
}

/* 송신 완료 콜백(사용하지 않지만 시그니처 맞춤) */
static void nus_sent_cb(const struct bt_uuid *uuid, uint8_t err)
{
    ARG_UNUSED(uuid);
    if (err) {
        LOG_WRN("NUS notify sent with error: 0x%02x", err);
    }
}

/* ===== NUS 서버 init 파라미터 ===== */
static struct bt_nus_cb nus_cb = {
    .received = nus_received_cb,
    .sent = nus_sent_cb,
};

/* ===== 연결 콜백 ===== */
static void connected(struct bt_conn *conn, uint8_t err)
{
    char addr[BT_ADDR_LE_STR_LEN];
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));

    if (err) {
        LOG_INF("Failed to connect to %s (%u)", addr, err);
        return;
    }

    current_conn = bt_conn_ref(conn);
    LOG_INF("Connected: %s", addr);

    /* MTU 교환(옵션) */
    static struct bt_gatt_exchange_params exchange_params;
    exchange_params.func = NULL;
    int ret = bt_gatt_exchange_mtu(conn, &exchange_params);
    if (ret) {
        LOG_WRN("MTU exchange failed (err %d)", ret);
    }
}

static void disconnected(struct bt_conn *conn, uint8_t reason)
{
    char addr[BT_ADDR_LE_STR_LEN];
    bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
    LOG_INF("Disconnected: %s (reason 0x%02x)", addr, reason);

    if (current_conn) {
        bt_conn_unref(current_conn);
        current_conn = NULL;
    }
}

BT_CONN_CB_DEFINE(conn_callbacks) = {
    .connected = connected,
    .disconnected = disconnected,
};

/* ===== UART 콜백 ===== */
static void uart_cb(const struct device *dev, struct uart_event *evt, void *user_data)
{
    ARG_UNUSED(dev);
    ARG_UNUSED(user_data);

    static size_t aborted_len;
    struct uart_data_t *buf;
    static uint8_t *aborted_buf;
    static bool disable_req;

    switch (evt->type) {
    case UART_TX_DONE: {
        if ((evt->data.tx.len == 0) || (!evt->data.tx.buf)) {
            return;
        }
        if (aborted_buf) {
            buf = CONTAINER_OF(aborted_buf, struct uart_data_t, data[0]);
            aborted_buf = NULL;
            aborted_len = 0;
        } else {
            buf = CONTAINER_OF(evt->data.tx.buf, struct uart_data_t, data[0]);
        }
        k_free(buf);

        buf = k_fifo_get(&fifo_uart_tx_data, K_NO_WAIT);
        if (!buf) {
            return;
        }
        if (uart_tx(uart, buf->data, buf->len, SYS_FOREVER_MS)) {
            LOG_WRN("Failed to send data over UART (retry)");
        }
        break;
    }

    case UART_RX_RDY: {
        /* [BIN] 라인 종결자를 기다리지 않고, 들어온 조각을 그대로 BLE로 보냄 */
        const uint8_t *p = &evt->data.rx.buf[evt->data.rx.offset];
        size_t n = evt->data.rx.len;

        if (current_conn && nus_dev && n > 0) {
            /* NUS 최대 보낼 수 있는 길이는 (ATT_MTU-3).
               zephyr는 bt_nus_send()가 내부에서 길이에 맞춰 조각내거나, 에러를 리턴.
               여기서는 조각내어 반복 송신. */
            size_t pos = 0;
            while (pos < n) {
                size_t chunk = MIN(n - pos, (size_t)UART_BUF_SIZE);
                int err = bt_nus_send(nus_dev, current_conn, &p[pos], chunk);
                if (err) {
                    LOG_WRN("bt_nus_send err=%d (chunk=%u)", err, (unsigned)chunk);
                    /* 에러가 나면 잠시 쉬고 재시도하거나 버퍼링 필요할 수 있음 */
                    /* 간단화: 여기선 중단 */
                    break;
                }
                pos += chunk;
            }
        }

        /* 기본 예제 흐름 유지용 (라인 종료시 RX_DISABLE 유도) */
        if (disable_req) {
            return;
        }
        if ((evt->data.rx.buf[evt->data.rx.offset + n - 1] == '\n') ||
            (evt->data.rx.buf[evt->data.rx.offset + n - 1] == '\r')) {
            disable_req = true;
            uart_rx_disable(uart);
        }
        break;
    }

    case UART_RX_DISABLED: {
        disable_req = false;

        /* 다음 RX 버퍼 재장전 */
        buf = k_malloc(sizeof(*buf));
        if (!buf) {
            LOG_WRN("Not able to allocate UART receive buffer");
            k_work_reschedule(&uart_work, UART_WAIT_FOR_BUF_DELAY);
            return;
        }
        buf->len = 0;
        uart_rx_enable(uart, buf->data, sizeof(buf->data), UART_RX_TIMEOUT_US);
        break;
    }

    case UART_RX_BUF_REQUEST: {
        buf = k_malloc(sizeof(*buf));
        if (buf) {
            buf->len = 0;
            uart_rx_buf_rsp(uart, buf->data, sizeof(buf->data));
        } else {
            LOG_WRN("Not able to allocate UART receive buffer");
        }
        break;
    }

    case UART_RX_BUF_RELEASED: {
        /* 기본 예제는 여기서 k_fifo_put을 하지만,
           우리는 바이너리 스트림 즉시 전송 방식이라 필수 아님.
           메모리 누수 방지로 free */
        buf = CONTAINER_OF(evt->data.rx_buf.buf, struct uart_data_t, data[0]);
        if (buf) {
            k_free(buf);
        }
        break;
    }

    case UART_TX_ABORTED: {
        if (!aborted_buf) {
            aborted_buf = (uint8_t *)evt->data.tx.buf;
        }
        aborted_len += evt->data.tx.len;
        buf = CONTAINER_OF(aborted_buf, struct uart_data_t, data[0]);
        uart_tx(uart, &buf->data[aborted_len], buf->len - aborted_len, SYS_FOREVER_MS);
        break;
    }

    default:
        break;
    }
}

/* ===== UART 초기화 ===== */
static void uart_work_handler(struct k_work *item)
{
    struct uart_data_t *buf = k_malloc(sizeof(*buf));
    if (!buf) {
        LOG_WRN("Not able to allocate UART receive buffer");
        k_work_reschedule(&uart_work, UART_WAIT_FOR_BUF_DELAY);
        return;
    }
    buf->len = 0;
    uart_rx_enable(uart, buf->data, sizeof(buf->data), UART_RX_TIMEOUT_US);
}

static int uart_init(void)
{
    int err;

    if (!device_is_ready(uart)) {
        LOG_ERR("UART device not ready");
        return -ENODEV;
    }

    k_work_init_delayable(&uart_work, uart_work_handler);

    err = uart_callback_set(uart, uart_cb, NULL);
    if (err) {
        return err;
    }

    /* 첫 RX 버퍼 투입 */
    struct uart_data_t *rx = k_malloc(sizeof(*rx));
    if (!rx) {
        return -ENOMEM;
    }
    rx->len = 0;

    return uart_rx_enable(uart, rx->data, sizeof(rx->data), UART_RX_TIMEOUT_US);
}

/* ===== 메인 ===== */
int main(void)
{
    int err;

    err = bt_enable(NULL);
    if (err) {
        LOG_ERR("Bluetooth init failed (err %d)", err);
        return 0;
    }
    LOG_INF("Bluetooth initialized");

    if (IS_ENABLED(CONFIG_SETTINGS)) {
        settings_load();
    }

    /* NUS 서버 초기화 */
    nus_dev = device_get_binding("BT_NUS");     /* overlay에서 label이 BT_NUS인 경우 */
    if (!nus_dev) {
        /* 최신 Zephyr에선 bt_nus_init(&nus_cb) 사용 */
        err = bt_nus_init(&nus_cb);
        if (err) {
            LOG_ERR("bt_nus_init failed (err %d)", err);
            return 0;
        }
    } else {
        bt_nus_cb_register(nus_dev, &nus_cb);
    }

    /* 광고 시작 */
    err = bt_le_adv_start(BT_LE_ADV_CONN, ad, ARRAY_SIZE(ad), NULL, 0);
    if (err) {
        LOG_ERR("Advertising failed to start (err %d)", err);
        return 0;
    }
    LOG_INF("Advertising successfully started");

    err = uart_init();
    if (err) {
        LOG_ERR("uart_init failed (err %d)", err);
        return 0;
    }

    /* 메인 루프: 특별히 할 일 없음 (콜백 기반) */
    for (;;) {
        k_sleep(K_SECONDS(1));
    }
}
